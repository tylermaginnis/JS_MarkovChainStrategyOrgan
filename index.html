<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Advanced Organ Composition with Markov Chains</title>
  <style>
    body {
      font-family: "Courier New", Courier, monospace;
      background-color: #1a1a1a;
      color: #00ff00;
      margin: 0;
      padding: 0;
    }
    h1 {
      font-size: 24px;
      text-transform: uppercase;
      color: #00ff00;
      text-align: center;
      margin-top: 20px;
      padding: 20px;
      border-bottom: 2px solid #00ff00;
      background-color: #111111;
    }
    button {
      font-family: "Courier New", Courier, monospace;
      background-color: #444444;
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 10px 20px;
      margin: 20px 10px;
      cursor: pointer;
      text-transform: uppercase;
      font-size: 16px;
      letter-spacing: 2px;
      transition: background-color 0.3s ease;
    }
    button:disabled {
      background-color: #333333;
      cursor: not-allowed;
    }
    button:hover {
      background-color: #555555;
    }
    #console {
      width: 90%;
      height: 400px;
      margin: 20px auto;
      padding: 10px;
      background-color: #111111;
      color: #00ff00;
      border: 1px solid #00ff00;
      overflow-y: scroll;
      font-family: "Courier New", Courier, monospace;
      font-size: 14px;
      white-space: pre-wrap;
      text-align: left;
    }
    #console div {
      margin-bottom: 5px;
    }
    .log-info {
      color: #00ff00;
    }
    .log-warn {
      color: #ffcc00;
    }
    .log-error {
      color: #ff0000;
    }
    .log-box {
      border: 1px solid #00ff00;
      padding: 5px;
      margin: 5px 0;
    }
    .chord {
      color: #ff66ff; /* Magenta for chords */
    }
    .frequency {
      color: #66ccff; /* Cyan for frequencies */
    }
    .rhythm {
      color: #ffff66; /* Yellow for rhythm */
    }
    .melody-strategy {
      color: #66ff66; /* Light green for melody strategy */
    }
    .ascii-box {
      border: 1px solid #00ff00;
      padding: 5px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>Advanced Organ Composition with Markov Chains</h1>
  <div style="text-align: center;">
    <button id="playButton">Play</button>
    <button id="stopButton" disabled>Stop</button>
  </div>
  <div id="console"></div>

  <script>
    let audioContext;
    let isPlaying = false;
    let oscillators = [];
    let schedulerId;
    const tempo = 90;
    const secondsPerBeat = 60 / tempo;
    const lookahead = 25.0;
    const scheduleAheadTime = 0.1;
    let nextNoteTime = 0.0;
    let currentChordStrategy = 'tonic';
    let currentMelodyStrategy = 'stepwise';
    let currentMelodyIndex = 0;

    const consoleDiv = document.getElementById('console');
    
    function logToConsole(message, type = 'info') {
      const logMessage = document.createElement('div');
      logMessage.innerHTML = message;
      logMessage.classList.add(`log-${type}`);
      consoleDiv.appendChild(logMessage);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    function logBox(content) {
      const box = document.createElement('div');
      box.classList.add('ascii-box');
      box.innerHTML = content;
      consoleDiv.appendChild(box);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    // Clears the console when new rhythm or chord strategy begins
    function clearConsole() {
      consoleDiv.innerHTML = "";
    }

    // Define Key Signature
    const keySignature = 'C';
    const majorScale = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25, 587.33, 659.26, 698.46, 784.00, 880.00, 987.77, 1046.50];

    // Extended Chord Strategies within Key of C Major
    const chordStrategies = {
      tonic: () => [261.63, 329.63, 392.00, 523.25], // C major 7
      dominant: () => [392.00, 493.88, 587.33, 784.00], // G major 7
      subdominant: () => [349.23, 440.00, 523.25, 698.46], // F major 7
      minor: () => [293.66, 369.99, 440.00, 587.33], // D minor 7
      diminished: () => [493.88, 622.25, 739.99, 987.77], // B diminished 7
      suspended: () => [261.63, 349.23, 392.00, 523.25], // C suspended
      minor7: () => [293.66, 349.23, 440.00, 523.25], // D minor 7
      augmented: () => [261.63, 329.63, 415.30, 523.25] // C augmented
    };

    // New Melody Strategies accepting currentChord
    const melodyStrategies = {
      stepwise: generateStepwiseMelody,
      leap: generateLeapingMelody,
      motif: generateMotifMelody,
      arpeggio: generateArpeggioMelody,
      pentatonic: generatePentatonicMelody,
      blues: generateBluesMelody,
      chordTones: generateChordTonesMelody,
      ascendingRun: generateAscendingRun,
      descendingRun: generateDescendingRun,
      randomWalk: generateRandomWalk
    };

    // Pentatonic and Blues Scales
    const pentatonicScale = [261.63, 293.66, 329.63, 392.00, 440.00];
    const bluesScale = [261.63, 293.66, 311.13, 329.63, 392.00, 466.16, 523.25];

    const scale = majorScale; // Use majorScale based on key signature

    // Updated Melody Generation Functions
    function generateStepwiseMelody(currentChord) {
      const direction = Math.random() < 0.5 ? -1 : 1;
      currentMelodyIndex = Math.max(0, Math.min(scale.length - 1, currentMelodyIndex + direction));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    function generateLeapingMelody(currentChord) {
      const leap = Math.random() < 0.5 ? 2 : 3;
      currentMelodyIndex = Math.max(0, Math.min(scale.length - 1, currentMelodyIndex + (Math.random() < 0.5 ? -leap : leap)));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    function generateMotifMelody(currentChord) {
      const motif = currentChord.length > 0 ? currentChord : [261.63, 293.66, 329.63];
      return motif[currentMelodyIndex++ % motif.length];
    }

    function generateArpeggioMelody(currentChord) {
      if (currentChord.length === 0) return scale[currentMelodyIndex++ % scale.length];
      return currentChord[currentMelodyIndex++ % currentChord.length];
    }

    function generatePentatonicMelody(currentChord) {
      const direction = Math.random() < 0.5 ? -1 : 1;
      currentMelodyIndex = Math.max(0, Math.min(pentatonicScale.length - 1, currentMelodyIndex + direction));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return pentatonicScale[currentMelodyIndex];
      }
    }

    function generateBluesMelody(currentChord) {
      const direction = Math.random() < 0.5 ? -1 : 1;
      currentMelodyIndex = Math.max(0, Math.min(bluesScale.length - 1, currentMelodyIndex + direction));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return bluesScale[currentMelodyIndex];
      }
    }

    function generateChordTonesMelody(currentChord) {
      if (currentChord.length === 0) return scale[currentMelodyIndex++ % scale.length];
      return currentChord[Math.floor(Math.random() * currentChord.length)];
    }

    function generateAscendingRun(currentChord) {
      currentMelodyIndex = Math.min(scale.length - 1, currentMelodyIndex + 1);
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    function generateDescendingRun(currentChord) {
      currentMelodyIndex = Math.max(0, currentMelodyIndex - 1);
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    function generateRandomWalk(currentChord) {
      const step = Math.floor(Math.random() * 3) - 1;
      currentMelodyIndex = Math.max(0, Math.min(scale.length - 1, currentMelodyIndex + step));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    function getNextStrategy(currentStrategy, markovMatrix) {
      const transitions = markovMatrix[currentStrategy];
      const strategies = Object.keys(transitions);
      const probabilities = Object.values(transitions);
      const randomValue = Math.random();
      let cumulativeProbability = 0;

      for (let i = 0; i < strategies.length; i++) {
        cumulativeProbability += probabilities[i];
        if (randomValue < cumulativeProbability) {
          return strategies[i];
        }
      }
      return currentStrategy;
    }

    // Updated Chord Strategy Markov Matrix for Smoother Transitions
    const chordStrategyMarkovMatrix = {
      tonic: { tonic: 0.3, dominant: 0.4, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      dominant: { tonic: 0.5, dominant: 0.2, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      subdominant: { tonic: 0.4, dominant: 0.3, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      minor: { tonic: 0.4, dominant: 0.3, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      diminished: { tonic: 0.4, dominant: 0.3, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      suspended: { tonic: 0.5, dominant: 0.3, subdominant: 0.15, minor: 0.025, diminished: 0.025, suspended: 0.0, minor7: 0.0, augmented: 0.0 },
      minor7: { tonic: 0.5, dominant: 0.3, subdominant: 0.15, minor: 0.025, diminished: 0.025, suspended: 0.0, minor7: 0.0, augmented: 0.0 },
      augmented: { tonic: 0.5, dominant: 0.3, subdominant: 0.15, minor: 0.025, diminished: 0.025, suspended: 0.0, minor7: 0.0, augmented: 0.0 }
    };

    const melodyStrategyMarkovMatrix = {
      stepwise: { stepwise: 0.3, leap: 0.2, motif: 0.1, arpeggio: 0.1, pentatonic: 0.1, chordTones: 0.05, blues: 0.05, randomWalk: 0.05 },
      leap: { stepwise: 0.2, leap: 0.5, motif: 0.1, arpeggio: 0.1, ascendingRun: 0.05, descendingRun: 0.05 },
      motif: { stepwise: 0.2, leap: 0.2, motif: 0.3, arpeggio: 0.1, pentatonic: 0.1 },
      arpeggio: { stepwise: 0.2, leap: 0.1, motif: 0.1, arpeggio: 0.4, pentatonic: 0.1 },
      pentatonic: { pentatonic: 0.6, chordTones: 0.2, stepwise: 0.1, blues: 0.1 },
      blues: { blues: 0.6, stepwise: 0.1, chordTones: 0.1, motif: 0.1, arpeggio: 0.1 },
      chordTones: { chordTones: 0.5, arpeggio: 0.2, stepwise: 0.1, randomWalk: 0.2 },
      ascendingRun: { ascendingRun: 0.5, descendingRun: 0.2, stepwise: 0.1, motif: 0.1 },
      descendingRun: { descendingRun: 0.5, ascendingRun: 0.2, stepwise: 0.1, motif: 0.1 },
      randomWalk: { randomWalk: 0.6, stepwise: 0.2, leap: 0.1, motif: 0.1 }
    };

    // Function to create a rich organ sound with careful layering
    function createOrganOscillator(frequency, startTime, duration, isChord = false) {
      const osc1 = audioContext.createOscillator();
      const osc2 = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      // Create filters
      const lowPassFilter = audioContext.createBiquadFilter();
      lowPassFilter.type = 'lowpass';
      lowPassFilter.frequency.setValueAtTime(4000, startTime); // Increased cutoff frequency for a brighter sound

      const highPassFilter = audioContext.createBiquadFilter();
      highPassFilter.type = 'highpass';
      highPassFilter.frequency.setValueAtTime(200, startTime); // Keep high pass frequency

      // Use a sine wave and triangle wave for richness
      osc1.type = 'sine';  
      osc2.type = 'triangle'; // Slightly detuned for a richer sound
      osc1.frequency.setValueAtTime(frequency, startTime);
      osc2.frequency.setValueAtTime(frequency * 1.005, startTime); // Small detuning

      const targetGain = isChord ? 0.2 : 0.5; // Softer for chords
      gainNode.gain.setValueAtTime(0, startTime);
      gainNode.gain.linearRampToValueAtTime(targetGain, startTime + 0.1); // Smoother attack
      gainNode.gain.setValueAtTime(targetGain, startTime + duration - 0.1); // Sustain
      gainNode.gain.linearRampToValueAtTime(0, startTime + duration); // Smoother release

      // Connect nodes: Oscillators -> High-Pass -> Low-Pass -> Gain -> Destination
      osc1.connect(highPassFilter);
      osc2.connect(highPassFilter);
      highPassFilter.connect(lowPassFilter);
      lowPassFilter.connect(gainNode);
      gainNode.connect(audioContext.destination);

      osc1.start(startTime);
      osc2.start(startTime);
      osc1.stop(startTime + duration);
      osc2.stop(startTime + duration);

      oscillators.push({ osc1, osc2, gainNode });
      logToConsole(`Organ ${isChord ? "Chord" : "Melody"} played: <span class="frequency">${frequency.toFixed(2)}Hz</span>`, 'info');
    }

    function playChord(chord, currentTime) {
      logBox(`=== Chord Strategy: <span class="chord">${currentChordStrategy.toUpperCase()}</span> ===`);
      chord.forEach(frequency => {
        createOrganOscillator(frequency, currentTime, secondsPerBeat, true);
      });
    }

    function playMelody(pattern, currentTime, currentChord) {
      logBox(`>>> Melody Strategy: <span class="melody-strategy">${currentMelodyStrategy.toUpperCase()}</span> <<<`);
      pattern.forEach((beatDuration, index) => {
        const startTime = currentTime + index * beatDuration * secondsPerBeat;
        const frequency = melodyStrategies[currentMelodyStrategy](currentChord);
        createOrganOscillator(frequency, startTime, beatDuration * secondsPerBeat, false);
      });
    }

    function scheduler() {
      while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
        playMusic(nextNoteTime);
        scheduleNextNote();
      }
      schedulerId = setTimeout(scheduler, lookahead);
    }

    function scheduleNextNote() {
      nextNoteTime += secondsPerBeat;
    }

    function playMusic(currentTime) {
      clearConsole(); // Clear the console when a new rhythm strategy starts

      const chord = chordStrategies[currentChordStrategy]();
      playChord(chord, currentTime);

      const rhythmPattern = rhythmPatterns[Math.floor(Math.random() * rhythmPatterns.length)];
      logToConsole(`Rhythm Pattern: <span class="rhythm">${rhythmPattern.join(', ')}</span>`, 'info');
      playMelody(rhythmPattern, currentTime, chord); // Pass the current chord here

      currentChordStrategy = getNextStrategy(currentChordStrategy, chordStrategyMarkovMatrix);
      currentMelodyStrategy = getNextStrategy(currentMelodyStrategy, melodyStrategyMarkovMatrix);
    }

    function startPlaying() {
      if (isPlaying) return;
      isPlaying = true;

      initializeAudio();
      logToConsole('Music playback started.', 'info');
      nextNoteTime = audioContext.currentTime;
      scheduler();
    }

    function stopPlaying() {
      if (!isPlaying) return;
      isPlaying = false;
      clearTimeout(schedulerId);
      logToConsole('Music playback stopped.', 'warn');

      oscillators.forEach(({ osc1, osc2, gainNode }) => {
        osc1.stop();
        osc2.stop();
        gainNode.disconnect();
      });
      oscillators = [];
    }

    function initializeAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        logToConsole('AudioContext initialized.', 'info');
      } else if (audioContext.state === 'suspended') {
        audioContext.resume();
        logToConsole('AudioContext resumed.', 'info');
      }
    }

    document.getElementById('playButton').addEventListener('click', () => {
      startPlaying();
      document.getElementById('playButton').disabled = true;
      document.getElementById('stopButton').disabled = false;
    });

    document.getElementById('stopButton').addEventListener('click', () => {
      stopPlaying();
      document.getElementById('playButton').disabled = false;
      document.getElementById('stopButton').disabled = true;
    });

    // Updated Rhythm Patterns
    const rhythmPatterns = [
      [1, 0.5, 0.5, 1, 0.5, 0.5, 1],
      [1, 1, 0.5, 0.5, 1, 1, 1],
      [0.5, 0.5, 0.5, 0.5, 1, 1],
      [1, 0.25, 0.25, 1, 0.5, 0.5, 1],
      [0.25, 0.25, 0.5, 0.5, 1, 1, 1],
      [1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5], // Triplets
      [1, 0.5, 1, 0.5, 1, 0.5, 1], // Balanced pattern
      [1, 1, 0.75, 0.25, 1, 1] // Simplified dotted rhythms
    ];
  </script>
</body>
</html>
