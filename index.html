<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Advanced Organ Composition with Markov Chains</title>
  <style>
    body {
      font-family: "Courier New", Courier, monospace;
      background-color: #1a1a1a;
      color: #00ff00;
      margin: 0;
      padding: 0;
    }
    h1 {
      font-size: 28px;
      text-transform: uppercase;
      color: #00ff00;
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      border-bottom: 2px solid #00ff00;
      background-color: #111111;
    }
    .controls {
      width: 90%;
      margin: 20px auto;
      padding: 10px;
      background-color: #111111;
      border: 1px solid #00ff00;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-around;
      border-radius: 8px;
    }
    .control-group {
      margin: 10px;
      flex: 1 1 200px;
      min-width: 200px;
    }
    .control-group label {
      display: block;
      margin-bottom: 5px;
      color: #00ff00;
    }
    .control-group input[type="range"],
    .control-group select {
      width: 100%;
    }
    .buttons {
      text-align: center;
      margin-top: 20px;
    }
    button {
      font-family: "Courier New", Courier, monospace;
      background-color: #444444;
      color: #00ff00;
      border: 1px solid #00ff00;
      padding: 10px 20px;
      margin: 10px;
      cursor: pointer;
      text-transform: uppercase;
      font-size: 16px;
      letter-spacing: 2px;
      transition: background-color 0.3s ease;
      border-radius: 4px;
    }
    button:disabled {
      background-color: #333333;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background-color: #555555;
    }
    #console {
      width: 90%;
      height: 300px;
      margin: 20px auto;
      padding: 10px;
      background-color: #111111;
      color: #00ff00;
      border: 1px solid #00ff00;
      overflow-y: scroll;
      font-family: "Courier New", Courier, monospace;
      font-size: 14px;
      white-space: pre-wrap;
      text-align: left;
      border-radius: 8px;
    }
    #console div {
      margin-bottom: 5px;
    }
    .log-info {
      color: #00ff00;
    }
    .log-warn {
      color: #ffcc00;
    }
    .log-error {
      color: #ff0000;
    }
    .log-box {
      border: 1px solid #00ff00;
      padding: 5px;
      margin: 5px 0;
      border-radius: 4px;
    }
    .chord {
      color: #ff66ff;
    }
    .frequency {
      color: #66ccff;
    }
    .rhythm {
      color: #ffff66;
    }
    .melody-strategy {
      color: #66ff66;
    }
    .ascii-box {
      border: 1px solid #00ff00;
      padding: 5px;
      margin-bottom: 10px;
      border-radius: 4px;
    }
    .visual-feedback {
      width: 90%;
      margin: 20px auto;
      padding: 10px;
      background-color: #111111;
      color: #00ff00;
      border: 1px solid #00ff00;
      font-family: "Courier New", Courier, monospace;
      font-size: 16px;
      border-radius: 8px;
      display: flex;
      justify-content: space-around;
    }
    .visual-section {
      flex: 1;
      text-align: center;
    }
    .visual-section h3 {
      margin-bottom: 10px;
      color: #66ff66;
    }
  </style>
</head>
<body>
  <h1>Advanced Organ Composition with Markov Chains</h1>
  
  <!-- Controls Panel -->
  <div class="controls">
    <!-- Tempo Control -->
    <div class="control-group">
      <label for="tempo">Tempo: <span id="tempoValue">90</span> BPM</label>
      <input type="range" id="tempo" min="60" max="180" value="90">
    </div>
    
    <!-- Master Volume Control -->
    <div class="control-group">
      <label for="masterVolume">Master Volume</label>
      <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.7">
    </div>
    
    <!-- Chord Volume Control -->
    <div class="control-group">
      <label for="chordVolume">Chord Volume</label>
      <input type="range" id="chordVolume" min="0" max="1" step="0.01" value="0.2">
    </div>
    
    <!-- Melody Volume Control -->
    <div class="control-group">
      <label for="melodyVolume">Melody Volume</label>
      <input type="range" id="melodyVolume" min="0" max="1" step="0.01" value="0.5">
    </div>
    
    <!-- Reverb Control -->
    <div class="control-group">
      <label for="reverb">Reverb Intensity</label>
      <input type="range" id="reverb" min="0" max="1" step="0.01" value="0.3">
    </div>
    
    <!-- Chord Waveform Selection -->
    <div class="control-group">
      <label for="chordWaveform">Chord Waveform</label>
      <select id="chordWaveform">
        <option value="triangle">Triangle</option>
        <option value="sawtooth">Sawtooth</option>
        <option value="square">Square</option>
        <option value="sine" selected>Sine</option>
      </select>
    </div>
    
    <!-- Melody Waveform Selection -->
    <div class="control-group">
      <label for="melodyWaveform">Melody Waveform</label>
      <select id="melodyWaveform">
        <option value="sine" selected>Sine</option>
        <option value="triangle">Triangle</option>
        <option value="sawtooth">Sawtooth</option>
        <option value="square">Square</option>
      </select>
    </div>
    
    <!-- Mute Controls -->
    <div class="control-group">
      <button id="muteChords">Mute Chords</button>
      <button id="muteMelody">Mute Melody</button>
    </div>
  </div>
  
  <!-- Play and Stop Buttons -->
  <div class="buttons">
    <button id="playButton">Play</button>
    <button id="stopButton" disabled>Stop</button>
  </div>

  <!-- Visual Feedback -->
  <div class="visual-feedback">
  <canvas id="visualizationCanvas" width="800" height="200"></canvas>
</div>
  
  <!-- Visual Feedback -->
  <div class="visual-feedback">
    <div class="visual-section">
      <h3>Current Chord</h3>
      <div id="currentChord">--</div>
    </div>
    <div class="visual-section">
      <h3>Current Melody</h3>
      <div id="currentMelody">--</div>
    </div>
    <div class="visual-section">
      <h3>Strategies</h3>
      <div>Chord: <span id="chordStrategy">--</span></div>
      <div>Melody: <span id="melodyStrategy">--</span></div>
    </div>
  </div>
  
  <!-- Console Logs -->
  <div id="console"></div>
  
  <script>
    // Initialize variables
    let audioContext;
    let isPlaying = false;
    let oscillators = [];
    let schedulerId;
    let masterGain;
    let reverbNode;
    let isChordsMuted = false;
    let isMelodyMuted = false;

    // Tempo and Volume Controls
    let tempo = 90;
    let masterVolume = 0.7;
    let chordVolume = 0.2;
    let melodyVolume = 0.5;
    let reverbIntensity = 0.3;
    let chordWaveform = 'triangle';
    let melodyWaveform = 'sine';

    const secondsPerBeat = () => 60 / tempo;
    const lookahead = 25.0;
    const scheduleAheadTime = 0.1;
    let nextNoteTime = 0.0;
    let currentChordStrategy = 'tonic';
    let currentMelodyStrategy = 'stepwise';
    let currentMelodyIndex = 0;

    // DOM Elements
    const consoleDiv = document.getElementById('console');
    const tempoSlider = document.getElementById('tempo');
    const tempoValue = document.getElementById('tempoValue');
    const masterVolumeSlider = document.getElementById('masterVolume');
    const chordVolumeSlider = document.getElementById('chordVolume');
    const melodyVolumeSlider = document.getElementById('melodyVolume');
    const reverbSlider = document.getElementById('reverb');
    const chordWaveformSelect = document.getElementById('chordWaveform');
    const melodyWaveformSelect = document.getElementById('melodyWaveform');
    const playButton = document.getElementById('playButton');
    const stopButton = document.getElementById('stopButton');
    const muteChordsButton = document.getElementById('muteChords');
    const muteMelodyButton = document.getElementById('muteMelody');
    const currentChordDiv = document.getElementById('currentChord');
    const currentMelodyDiv = document.getElementById('currentMelody');
    const chordStrategySpan = document.getElementById('chordStrategy');
    const melodyStrategySpan = document.getElementById('melodyStrategy');

    // Logging Functions
    function logToConsole(message, type = 'info') {
      const logMessage = document.createElement('div');
      logMessage.innerHTML = message;
      logMessage.classList.add(`log-${type}`);
      consoleDiv.appendChild(logMessage);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    function logBox(content) {
      const box = document.createElement('div');
      box.classList.add('ascii-box');
      box.innerHTML = content;
      consoleDiv.appendChild(box);
      consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    // Clears the console when new rhythm or chord strategy begins
    function clearConsole() {
      consoleDiv.innerHTML = "";
    }

    // Define Key Signature
    const keySignature = 'C';
    const majorScale = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25, 587.33, 659.26, 698.46, 784.00, 880.00, 987.77, 1046.50];

    // Extended Chord Strategies within Key of C Major
    const chordStrategies = {
      tonic: () => [261.63, 329.63, 392.00, 523.25], // C major 7
      dominant: () => [392.00, 493.88, 587.33, 784.00], // G major 7
      subdominant: () => [349.23, 440.00, 523.25, 698.46], // F major 7
      minor: () => [293.66, 369.99, 440.00, 587.33], // D minor 7
      diminished: () => [493.88, 622.25, 739.99, 987.77], // B diminished 7
      suspended: () => [261.63, 349.23, 392.00, 523.25], // C suspended
      minor7: () => [293.66, 349.23, 440.00, 523.25], // D minor 7
      augmented: () => [261.63, 329.63, 415.30, 523.25] // C augmented
    };

    // Melody Strategies
    const melodyStrategies = {
      stepwise: generateStepwiseMelody,
      leap: generateLeapingMelody,
      motif: generateMotifMelody,
      arpeggio: generateArpeggioMelody,
      pentatonic: generatePentatonicMelody,
      blues: generateBluesMelody,
      chordTones: generateChordTonesMelody,
      ascendingRun: generateAscendingRun,
      descendingRun: generateDescendingRun,
      randomWalk: generateRandomWalk
    };

    // Pentatonic and Blues Scales
    const pentatonicScale = [261.63, 293.66, 329.63, 392.00, 440.00];
    const bluesScale = [261.63, 293.66, 311.13, 329.63, 392.00, 466.16, 523.25];

    const scale = majorScale; // Use majorScale based on key signature

    // Melody Generation Functions
    function generateStepwiseMelody(currentChord) {
      const direction = Math.random() < 0.5 ? -1 : 1;
      currentMelodyIndex = Math.max(0, Math.min(scale.length - 1, currentMelodyIndex + direction));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    function generateLeapingMelody(currentChord) {
      const leap = Math.random() < 0.5 ? 2 : 3;
      currentMelodyIndex = Math.max(0, Math.min(scale.length - 1, currentMelodyIndex + (Math.random() < 0.5 ? -leap : leap)));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    function generateMotifMelody(currentChord) {
      const motif = currentChord.length > 0 ? currentChord : [261.63, 293.66, 329.63];
      return motif[currentMelodyIndex++ % motif.length];
    }

    function generateArpeggioMelody(currentChord) {
      if (currentChord.length === 0) return scale[currentMelodyIndex++ % scale.length];
      return currentChord[currentMelodyIndex++ % currentChord.length];
    }

    function generatePentatonicMelody(currentChord) {
      const direction = Math.random() < 0.5 ? -1 : 1;
      currentMelodyIndex = Math.max(0, Math.min(pentatonicScale.length - 1, currentMelodyIndex + direction));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return pentatonicScale[currentMelodyIndex];
      }
    }

    function generateBluesMelody(currentChord) {
      const direction = Math.random() < 0.5 ? -1 : 1;
      currentMelodyIndex = Math.max(0, Math.min(bluesScale.length - 1, currentMelodyIndex + direction));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return bluesScale[currentMelodyIndex];
      }
    }

    function generateChordTonesMelody(currentChord) {
      if (currentChord.length === 0) return scale[currentMelodyIndex++ % scale.length];
      return currentChord[Math.floor(Math.random() * currentChord.length)];
    }

    function generateAscendingRun(currentChord) {
      currentMelodyIndex = Math.min(scale.length - 1, currentMelodyIndex + 1);
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    function generateDescendingRun(currentChord) {
      currentMelodyIndex = Math.max(0, currentMelodyIndex - 1);
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    function generateRandomWalk(currentChord) {
      const step = Math.floor(Math.random() * 3) - 1;
      currentMelodyIndex = Math.max(0, Math.min(scale.length - 1, currentMelodyIndex + step));
      // Prioritize chord tones
      if (Math.random() < 0.7 && currentChord.length > 0) {
        return currentChord[Math.floor(Math.random() * currentChord.length)];
      } else {
        return scale[currentMelodyIndex];
      }
    }

    // Function to get the next strategy based on Markov matrix
    function getNextStrategy(currentStrategy, markovMatrix) {
      const transitions = markovMatrix[currentStrategy];
      const strategies = Object.keys(transitions);
      const probabilities = Object.values(transitions);
      const randomValue = Math.random();
      let cumulativeProbability = 0;

      for (let i = 0; i < strategies.length; i++) {
        cumulativeProbability += probabilities[i];
        if (randomValue < cumulativeProbability) {
          return strategies[i];
        }
      }
      return currentStrategy;
    }

    // Chord Strategy Markov Matrix
    const chordStrategyMarkovMatrix = {
      tonic: { tonic: 0.3, dominant: 0.4, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      dominant: { tonic: 0.5, dominant: 0.2, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      subdominant: { tonic: 0.4, dominant: 0.3, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      minor: { tonic: 0.4, dominant: 0.3, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      diminished: { tonic: 0.4, dominant: 0.3, subdominant: 0.2, minor: 0.05, diminished: 0.025, suspended: 0.025, minor7: 0.0, augmented: 0.0 },
      suspended: { tonic: 0.5, dominant: 0.3, subdominant: 0.15, minor: 0.025, diminished: 0.025, suspended: 0.0, minor7: 0.0, augmented: 0.0 },
      minor7: { tonic: 0.5, dominant: 0.3, subdominant: 0.15, minor: 0.025, diminished: 0.025, suspended: 0.0, minor7: 0.0, augmented: 0.0 },
      augmented: { tonic: 0.5, dominant: 0.3, subdominant: 0.15, minor: 0.025, diminished: 0.025, suspended: 0.0, minor7: 0.0, augmented: 0.0 }
    };

    // Melody Strategy Markov Matrix
    const melodyStrategyMarkovMatrix = {
      stepwise: { stepwise: 0.3, leap: 0.2, motif: 0.1, arpeggio: 0.1, pentatonic: 0.1, chordTones: 0.05, blues: 0.05, randomWalk: 0.05 },
      leap: { stepwise: 0.2, leap: 0.5, motif: 0.1, arpeggio: 0.1, ascendingRun: 0.05, descendingRun: 0.05 },
      motif: { stepwise: 0.2, leap: 0.2, motif: 0.3, arpeggio: 0.1, pentatonic: 0.1 },
      arpeggio: { stepwise: 0.2, leap: 0.1, motif: 0.1, arpeggio: 0.4, pentatonic: 0.1 },
      pentatonic: { pentatonic: 0.6, chordTones: 0.2, stepwise: 0.1, blues: 0.1 },
      blues: { blues: 0.6, stepwise: 0.1, chordTones: 0.1, motif: 0.1, arpeggio: 0.1 },
      chordTones: { chordTones: 0.5, arpeggio: 0.2, stepwise: 0.1, randomWalk: 0.2 },
      ascendingRun: { ascendingRun: 0.5, descendingRun: 0.2, stepwise: 0.1, motif: 0.1 },
      descendingRun: { descendingRun: 0.5, ascendingRun: 0.2, stepwise: 0.1, motif: 0.1 },
      randomWalk: { randomWalk: 0.6, stepwise: 0.2, leap: 0.1, motif: 0.1 }
    };

    // Function to create a reverb effect using a ConvolverNode
    function createReverb(audioContext) {
      const convolver = audioContext.createConvolver();
      // Simple impulse response for reverb
      const rate = audioContext.sampleRate;
      const length = rate * 2; // 2 seconds
      const impulse = audioContext.createBuffer(2, length, rate);
      for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
        }
      }
      convolver.buffer = impulse;
      return convolver;
    }

    // Function to create a rich organ sound with careful layering
    function createOrganOscillator(frequency, startTime, duration, isChord = false, chord = []) {
      const osc1 = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      const panner = audioContext.createStereoPanner();

      // Create filters
      const lowPassFilter = audioContext.createBiquadFilter();
      lowPassFilter.type = 'lowpass';
      lowPassFilter.frequency.setValueAtTime(4000, startTime); // Increased cutoff frequency for a brighter sound

      const highPassFilter = audioContext.createBiquadFilter();
      highPassFilter.type = 'highpass';
      highPassFilter.frequency.setValueAtTime(200, startTime); // Keep high pass frequency

      // Set waveforms based on whether it's a chord or melody
      osc1.type = isChord ? chordWaveform : melodyWaveform;
      osc1.frequency.setValueAtTime(frequency, startTime);

      // Apply minimal detuning for chords to add richness
      if (isChord && !isChordsMuted) {
        osc1.detune.setValueAtTime(2, startTime); // Slight detuning
      }

      // Volume settings
      const targetGain = isChord ? chordVolume : melodyVolume;
      gainNode.gain.setValueAtTime(0, startTime);
      gainNode.gain.linearRampToValueAtTime(targetGain, startTime + 0.1); // Smooth attack
      gainNode.gain.setValueAtTime(targetGain, startTime + duration - 0.1); // Sustain
      gainNode.gain.linearRampToValueAtTime(0, startTime + duration); // Smooth release

      // Stereo Panning
      panner.pan.setValueAtTime(isChord ? 0 : 0.2, startTime); // Center chords, slightly right for melody

      // Connect nodes: Oscillator -> High-Pass -> Low-Pass -> Gain -> Panner -> Reverb -> Master Gain
      osc1.connect(highPassFilter);
      highPassFilter.connect(lowPassFilter);
      lowPassFilter.connect(gainNode);
      gainNode.connect(panner);
      panner.connect(reverbNode);
      reverbNode.connect(masterGain);

      osc1.start(startTime);
      osc1.stop(startTime + duration);

      oscillators.push({ osc1, gainNode });
      logToConsole(`Organ ${isChord ? "Chord" : "Melody"} played: <span class="frequency">${frequency.toFixed(2)}Hz</span>`, 'info');

      // Update Visual Feedback
      if (isChord) {
        currentChordDiv.innerHTML = chord.map(freq => freq.toFixed(2) + 'Hz').join(', ');
      } else {
        currentMelodyDiv.innerHTML = frequency.toFixed(2) + 'Hz';
      }
    }

    function playChord(chord, currentTime) {
      logBox(`=== Chord Strategy: <span class="chord">${currentChordStrategy.toUpperCase()}</span> ===`);
      chord.forEach(frequency => {
        if (!isChordsMuted) {
          createOrganOscillator(frequency, currentTime, secondsPerBeat(), true, chord);
        }
      });
    }

    function playMelody(pattern, currentTime, currentChord) {
      logBox(`>>> Melody Strategy: <span class="melody-strategy">${currentMelodyStrategy.toUpperCase()}</span> <<<`);
      pattern.forEach((beatDuration, index) => {
        const startTime = currentTime + index * beatDuration * secondsPerBeat();
        const frequency = melodyStrategies[currentMelodyStrategy](currentChord);
        if (!isMelodyMuted) {
          createOrganOscillator(frequency, startTime, beatDuration * secondsPerBeat(), false);
        }
      });
    }

    function scheduler() {
      while (nextNoteTime < audioContext.currentTime + scheduleAheadTime) {
        playMusic(nextNoteTime);
        scheduleNextNote();
      }
      schedulerId = setTimeout(scheduler, lookahead);
    }

    function scheduleNextNote() {
      nextNoteTime += secondsPerBeat();
    }

    function playMusic(currentTime) {
      // Only clear console when a new chord strategy starts
      if (currentTime !== nextNoteTime) {
        clearConsole();
      }

      const chord = chordStrategies[currentChordStrategy]();
      playChord(chord, currentTime);

      const rhythmPattern = rhythmPatterns[Math.floor(Math.random() * rhythmPatterns.length)];
      logToConsole(`Rhythm Pattern: <span class="rhythm">${rhythmPattern.join(', ')}</span>`, 'info');
      playMelody(rhythmPattern, currentTime, chord); // Pass the current chord here

      // Update Strategy Indicators
      chordStrategySpan.textContent = currentChordStrategy.toUpperCase();
      melodyStrategySpan.textContent = currentMelodyStrategy.toUpperCase();

      currentChordStrategy = getNextStrategy(currentChordStrategy, chordStrategyMarkovMatrix);
      currentMelodyStrategy = getNextStrategy(currentMelodyStrategy, melodyStrategyMarkovMatrix);
    }

    function startPlaying() {
      if (isPlaying) return;
      isPlaying = true;

      initializeAudio();
      logToConsole('Music playback started.', 'info');
      nextNoteTime = audioContext.currentTime;
      scheduler();
    }

    function stopPlaying() {
      if (!isPlaying) return;
      isPlaying = false;
      clearTimeout(schedulerId);
      logToConsole('Music playback stopped.', 'warn');

      oscillators.forEach(({ osc1, gainNode }) => {
        try {
          osc1.stop();
        } catch (e) {
          // Oscillator already stopped
        }
        gainNode.disconnect();
      });
      oscillators = [];
      currentChordDiv.innerHTML = '--';
      currentMelodyDiv.innerHTML = '--';
      chordStrategySpan.textContent = '--';
      melodyStrategySpan.textContent = '--';
    }

    function initializeAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Create master gain node
        masterGain = audioContext.createGain();
        masterGain.gain.setValueAtTime(masterVolume, audioContext.currentTime);

        // Create and connect reverb
        reverbNode = createReverb(audioContext);
        reverbNode.connect(masterGain);
        masterGain.connect(audioContext.destination);

        logToConsole('AudioContext initialized with reverb.', 'info');
      } else if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          logToConsole('AudioContext resumed after user interaction.', 'info');
        });
      }
    }

    // Event Listeners for Controls
    tempoSlider.addEventListener('input', () => {
      tempo = parseInt(tempoSlider.value);
      tempoValue.textContent = tempo;
      logToConsole(`Tempo set to ${tempo} BPM`, 'info');
    });

    masterVolumeSlider.addEventListener('input', () => {
      masterVolume = parseFloat(masterVolumeSlider.value);
      masterGain.gain.setValueAtTime(masterVolume, audioContext.currentTime);
      logToConsole(`Master Volume set to ${masterVolume}`, 'info');
    });

    chordVolumeSlider.addEventListener('input', () => {
      chordVolume = parseFloat(chordVolumeSlider.value);
      logToConsole(`Chord Volume set to ${chordVolume}`, 'info');
    });

    melodyVolumeSlider.addEventListener('input', () => {
      melodyVolume = parseFloat(melodyVolumeSlider.value);
      logToConsole(`Melody Volume set to ${melodyVolume}`, 'info');
    });

    reverbSlider.addEventListener('input', () => {
      reverbIntensity = parseFloat(reverbSlider.value);
      reverbNode.normalize = false;
      reverbNode.buffer.getChannelData(0).forEach((value, index, array) => {
        array[index] = value * reverbIntensity;
      });
      reverbNode.buffer.getChannelData(1).forEach((value, index, array) => {
        array[index] = value * reverbIntensity;
      });
      logToConsole(`Reverb Intensity set to ${reverbIntensity}`, 'info');
    });

    chordWaveformSelect.addEventListener('change', () => {
      chordWaveform = chordWaveformSelect.value;
      logToConsole(`Chord Waveform set to ${chordWaveform}`, 'info');
    });

    melodyWaveformSelect.addEventListener('change', () => {
      melodyWaveform = melodyWaveformSelect.value;
      logToConsole(`Melody Waveform set to ${melodyWaveform}`, 'info');
    });

    muteChordsButton.addEventListener('click', () => {
      isChordsMuted = !isChordsMuted;
      muteChordsButton.textContent = isChordsMuted ? 'Unmute Chords' : 'Mute Chords';
      logToConsole(`Chords ${isChordsMuted ? 'Muted' : 'Unmuted'}`, 'warn');
    });

    muteMelodyButton.addEventListener('click', () => {
      isMelodyMuted = !isMelodyMuted;
      muteMelodyButton.textContent = isMelodyMuted ? 'Unmute Melody' : 'Mute Melody';
      logToConsole(`Melody ${isMelodyMuted ? 'Muted' : 'Unmuted'}`, 'warn');
    });

    playButton.addEventListener('click', () => {
      startPlaying();
      playButton.disabled = true;
      stopButton.disabled = false;
    });

    stopButton.addEventListener('click', () => {
      stopPlaying();
      playButton.disabled = false;
      stopButton.disabled = true;
    });

    // Rhythm Patterns
    const rhythmPatterns = [
      [1, 0.5, 0.5, 1, 0.5, 0.5, 1],
      [1, 1, 0.5, 0.5, 1, 1, 1],
      [0.5, 0.5, 0.5, 0.5, 1, 1],
      [1, 0.25, 0.25, 1, 0.5, 0.5, 1],
      [0.25, 0.25, 0.5, 0.5, 1, 1, 1],
      [1, 1, 1, 1, 0.5, 0.5, 0.5, 0.5], // Triplets
      [1, 0.5, 1, 0.5, 1, 0.5, 1], // Balanced pattern
      [1, 1, 0.75, 0.25, 1, 1] // Simplified dotted rhythms
    ];


  // Start the audio context on user interaction to comply with browser policies
  document.body.addEventListener('click', () => {
    if (!audioContext) {
      initializeAudio();
    } else if (audioContext.state === 'suspended') {
      audioContext.resume();
    }
  }, { once: true });

  const canvas = document.getElementById('visualizationCanvas');
  const canvasContext = canvas.getContext('2d');
  let analyser;

  function drawVisualization() {
    if (!analyser) return;
    requestAnimationFrame(drawVisualization);
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    analyser.getByteTimeDomainData(dataArray);

    canvasContext.fillStyle = 'rgb(17, 17, 17)';
    canvasContext.fillRect(0, 0, canvas.width, canvas.height);

    canvasContext.lineWidth = 2;
    canvasContext.strokeStyle = 'rgb(0, 255, 0)';
    canvasContext.beginPath();

    const sliceWidth = canvas.width * 1.0 / bufferLength;
    let x = 0;

    for (let i = 0; i < bufferLength; i++) {
      const v = dataArray[i] / 128.0;
      const y = v * canvas.height / 2;

      if (i === 0) {
        canvasContext.moveTo(x, y);
      } else {
        canvasContext.lineTo(x, y);
      }

      x += sliceWidth;
    }

    canvasContext.lineTo(canvas.width, canvas.height / 2);
    canvasContext.stroke();
  }

  function initializeAudio() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();

      // Create master gain node
      masterGain = audioContext.createGain();
      masterGain.gain.setValueAtTime(masterVolume, audioContext.currentTime);

      // Create and connect reverb
      reverbNode = createReverb(audioContext);
      reverbNode.connect(masterGain);
      masterGain.connect(audioContext.destination);

      // Create analyser node
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 2048; // Set FFT size for better resolution
      masterGain.connect(analyser);

      logToConsole('AudioContext initialized with reverb and analyser.', 'info');
    } else if (audioContext.state === 'suspended') {
      audioContext.resume().then(() => {
        logToConsole('AudioContext resumed after user interaction.', 'info');
      });
    }
  }

  // Ensure drawVisualization is called continuously
  function startVisualization() {
    if (!analyser) return;
    drawVisualization();
  }

  // Start visualization when audio context is initialized
  document.body.addEventListener('click', startVisualization, { once: true });

  </script>
</body>
</html>
